# SM121a (GB10) Complete SASS Instruction Encoding Map

*Generated by SASSquatch ISA audit tooling*

## Executive Summary

| Metric | Phase 4 (original) | Phase 5 (deep sweep) |
|--------|--------------------|-----------------------|
| 12-bit opcode entries decoded | 245 | 248 |
| Unique mnemonics | 199 | **1,894** |
| Instruction families | ~80 | **145** |
| QMMA (MMA) variants | 2 | **78** |

Phase 4 treated `lo64[11:0]` as a flat 12-bit opcode space. Phase 5 discovered
that instruction identity is determined by **multiple bit fields across the full
128-bit instruction word**, producing a 9.5× expansion in known instruction
variants.

---

## Corrected Encoding Model

### 128-bit Instruction Layout

```
127                              64 63                               0
+----------------------------------+----------------------------------+
|           hi64 (upper)           |           lo64 (lower)           |
+----------------------------------+----------------------------------+
```

### lo64: Opcode + Operands

```
63    56 55    48 47    40 39    32 31    24 23    16 15  12 11  9 8   0
+-------+-------+-------+-------+-------+-------+-----+----+-------+
| Modi- | Modi- | Src C | Src B | Src A |  Dst  |Pred |Mode| Major |
| fiers | fiers |  Rc   |  Rb   |  Ra   |  Rd   |  P  |    |Opcode |
+-------+-------+-------+-------+-------+-------+-----+----+-------+
```

| Field | Bits | Width | Description |
|-------|------|-------|-------------|
| **Major Opcode** | [8:0] | 9 bits | Selects instruction family. 165 unique values used. |
| **Source Mode** | [11:9] | 3 bits | Operand encoding mode (see table below) |
| **Predicate** | [15:12] | 4 bits | Predicate register for conditional execution |
| **Destination** | [23:16] | 8 bits | Destination register Rd |
| **Source A** | [31:24] | 8 bits | First source register Ra |
| **Source B** | [39:32] | 8 bits | Second source Rb (or immediate low bits) |
| **Source C** | [47:40] | 8 bits | Third source Rc (or cbuf offset) |
| **Modifiers** | [63:48] | 16 bits | Instruction-specific modifier fields |

**Important**: `lo64[11:0]` is NOT a single 12-bit opcode. It is two independent
fields: a 9-bit major opcode and a 3-bit source mode selector. The same logical
instruction (e.g., SHFL) appears at **multiple** 12-bit values because the source
mode changes which register/immediate encoding the instruction uses.

### Source Mode Field (bits [11:9])

| Mode | Binary | 12-bit codes | Meaning |
|------|--------|-------------|---------|
| 1 | `001` | 0x200-0x3FF | Register-Register (most common, 106 opcodes) |
| 2 | `010` | 0x400-0x5FF | Register-Immediate (24 opcodes) |
| 3 | `011` | 0x600-0x7FF | Low-frequency mode (1 opcode: SEL.64) |
| 4 | `100` | 0x800-0x9FF | Register-Constant Buffer (111 opcodes) |
| 5 | `101` | 0xA00-0xBFF | Low-frequency mode (3 opcodes: BAR, CCTL) |
| 7 | `111` | 0xE00-0xFFF | Low-frequency mode (3 opcodes: SHFL, BMOV) |
| 0, 6 | `000`, `110` | — | **Not observed** |

**Example**: `SHFL` has major opcode `0x189` (bits[8:0]). It appears at:
- `0x389` (mode 1: reg-reg)
- `0x589` (mode 2: reg-imm)
- `0x989` (mode 4: reg-cbuf)
- `0xf89` (mode 7: low-frequency mode)

### hi64: Function Selectors + Scheduling

```
63    52 51      44 43  27 26  23 22 20 19  17 16  13 12 11  9 8
+-------+---------+------+-----+----+------+-----+--+----+--+
| Sched | Barrier | Val/ | Op  |Cach| Rsvd |Scope|Fm|Type|Ex|
| Info  | Masks   | Rsvd | Func| Mod|      |     |  |    |  |
+-------+---------+------+-----+----+------+-----+--+----+--+
```

| Field | Bits | Width | Description | Example modifiers |
|-------|------|-------|-------------|-------------------|
| **Extended** | 8 | 1 bit | Extended addressing flag | `.E`, `.BA` |
| **Data Type** | [11:9] | 3 bits | Operand data type | `.S32`, `.64`, `.128`, `.F16` |
| **Format** | [13:12] | 2 bits | Data format selector | `.E4M3`, `.E5M2`, `.BF16` |
| **Scope** | [16:14] | 3 bits | Memory scope | `.CONSTANT`, `.STRONG`, `.MMIO` |
| **Cache Mode** | [22:20] | 3 bits | Cache eviction policy | `.EF`, `.EL`, `.EU` |
| **Op Function** | [26:23] | 4 bits | Operation type | `.ADD`, `.XOR`, `.OR`, `.AND`, `.CAS` |
| **Validity** | 27, [44:43] | 3 bits | Must be 0 or decode fails | — |
| **Scheduling** | [63:45] | 19 bits | Stall counts, barriers, yield | — |

**Observed finding**: The hi64 function fields determine which **specific operation**
within an instruction family is being performed. For example, `ATOM` at major opcode
`0x18a` becomes `ATOM.ADD`, `ATOM.XOR`, `ATOM.OR`, `ATOM.AND`, `ATOM.INC`,
`ATOM.CAS` etc. depending entirely on hi64 bits [26:23].

### lo64 Modifier Fields (instruction-specific)

Some instructions use lo64 bits [63:48] for sub-opcode selection:

| Instruction | lo64 Bits | Function |
|-------------|-----------|----------|
| SHFL | [59:58] | Shuffle mode: IDX (00), UP (01), DOWN (10), BFLY (11) |
| BRA/JMP | [33:32] | Convergence: CONV (00), DIV (01), U (10) |
| TEX | [60:56] | Addressing mode, UAI flag |
| SUATOM | [63:58] | Dimensionality (1D, 2D, 1D_ARRAY, 2D_ARRAY, BUFFER) |
| IMAD | [39:32] | Source B register (0xFF → MOV form, else standard) |

---

## Discovery Methodology

| Phase | Method | What it found |
|-------|--------|---------------|
| **Phase 1-2** | PTX compilation + disassembly | Compiler-reachable opcodes |
| **Phase 3** | Hardware fuzzing (all 4096 lo64[11:0]) | Which opcodes execute on silicon |
| **Phase 4** | nvdisasm raw-mode probing | Mnemonic for each 12-bit code (10 hi64 templates) |
| **Phase 5a** | Single-bit-flip analysis | Identified which bit positions are function selectors |
| **Phase 5b** | Systematic hi64 sweep (69 patterns × 456 opcodes) | 1,894 unique mnemonics |
| **Phase 5c** | Exhaustive QMMA cross-product (8,248 hi64 × 2 opcodes) | 78 MMA variants |

### Phase 5a: Bit-Flip Function Identification

For each multi-mnemonic opcode from Phase 4, we flipped individual bits in hi64
and lo64 to determine which bit positions change the mnemonic. Key results:

- **hi64[26:23]** (Op Function): Changes atomic operation type across all ATOM/ATOMG/REDG/SUATOM
  - Bit 23: ATOM.XOR → ATOM.OR
  - Bit 24: ATOM.XOR → ATOM.AND
  - Bit 25: ATOM.XOR → ATOM.INC

- **hi64[22:20]** (Cache Mode): Changes cache policy for memory instructions
  - 000: `.EF` (evict first), 001: no suffix, 010: `.EL`, 100: `.EU`

- **hi64[11:9]** (Data Type): Changes operand width
  - Bit 9: `.S32`, Bit 10: `.64`, Bit 11: `.128`

- **hi64 bits 27, 43, 44**: Flipping ANY of these causes decode failure for ALL tested
  opcodes. These appear to be instruction **validity/format bits** that must be 0.

---

## Instruction Families

### Summary Statistics

| Category | Families | Total Variants | Top family |
|----------|----------|---------------|------------|
| Atomic/Memory | 10 | 654 | ATOM (131) |
| Tensor Core (MMA) | 3 | 119 | QMMA (78) |
| Float Arithmetic | 8 | 196 | FMUL (39) |
| Integer Arithmetic | 8 | 77 | IMAD (14) |
| Half-precision | 5 | 138 | HSET2 (32) |
| Comparison/Set | 4 | 126 | FSETP (35) |
| Memory Load/Store | 6 | 171 | SULD (68) |
| Type Conversion | 4 | 107 | F2FP (33) |
| Control Flow | 8 | ~30 | BRA (8) |
| Other | ~89 | ~276 | MEMBAR (33) |

---

## Tensor Core MMA Instructions (QMMA)

**78 variants discovered** across 2 opcodes. This document provides a detailed
experimental map of observed SM121a MMA instruction encodings.

### QMMA Encoding Dimensions

| Dimension | Values | Description |
|-----------|--------|-------------|
| **Tile Shape** | `16816`, `16832`, `16864` | M×N×K tile dimensions |
| | `INVALID0`, `INVALID2`, `INVALID3` | Undocumented tile configurations |
| **Output Type** | `F16`, `F32` | Accumulator precision |
| **Input A Type** | `E4M3`, `E5M2` | FP8 format for matrix A |
| **Input B Type** | `E4M3`, `E5M2`, `E2M3`, `INVALID6` | FP8/FP4(?) formats for matrix B |
| **Flags** | `SF` (Scale Factor), `SP` (Structured Sparsity), `E8` (FP8 Scale) | |

### QMMA Opcode Assignment

| Opcode | Mode | Variant count | Description |
|--------|------|---------------|-------------|
| `0x27a` | 1 (reg-reg) | 68 | Standard and SP MMA |
| `0x47a` | 2 (reg-imm) | 10 | Scale Factor (SF) MMA |

### All 78 QMMA Mnemonics

**Standard (non-sparse, non-SF)** -- Opcode 0x27a:

| Mnemonic | Tile | Output | Input A | Input B |
|----------|------|--------|---------|---------|
| `QMMA.16816.F16.E4M3.E4M3` | 16×8×16 | F16 | E4M3 | E4M3 |
| `QMMA.16816.F16.E4M3.E5M2` | 16×8×16 | F16 | E4M3 | E5M2 |
| `QMMA.16816.F16.E4M3.E2M3` | 16×8×16 | F16 | E4M3 | E2M3 |
| `QMMA.16816.F16.E5M2.E4M3` | 16×8×16 | F16 | E5M2 | E4M3 |
| `QMMA.16816.F16.E5M2.E5M2` | 16×8×16 | F16 | E5M2 | E5M2 |
| `QMMA.16816.F32.E4M3.E4M3` | 16×8×16 | F32 | E4M3 | E4M3 |
| `QMMA.16816.F32.E4M3.E5M2` | 16×8×16 | F32 | E4M3 | E5M2 |
| `QMMA.16816.F32.E5M2.E4M3` | 16×8×16 | F32 | E5M2 | E4M3 |
| `QMMA.16816.F32.E5M2.E5M2` | 16×8×16 | F32 | E5M2 | E5M2 |
| `QMMA.16832.F16.E4M3.E4M3` | 16×8×32 | F16 | E4M3 | E4M3 |
| `QMMA.16832.F16.E4M3.E5M2` | 16×8×32 | F16 | E4M3 | E5M2 |
| `QMMA.16832.F16.E4M3.E2M3` | 16×8×32 | F16 | E4M3 | E2M3 |
| `QMMA.16832.F16.E5M2.E4M3` | 16×8×32 | F16 | E5M2 | E4M3 |
| `QMMA.16832.F16.E5M2.E5M2` | 16×8×32 | F16 | E5M2 | E5M2 |
| `QMMA.16832.F32.E4M3.E4M3` | 16×8×32 | F32 | E4M3 | E4M3 |
| `QMMA.16832.F32.E4M3.E5M2` | 16×8×32 | F32 | E4M3 | E5M2 |
| `QMMA.16832.F32.E5M2.E4M3` | 16×8×32 | F32 | E5M2 | E4M3 |
| `QMMA.16832.F32.E5M2.E5M2` | 16×8×32 | F32 | E5M2 | E5M2 |

**INVALID tile shapes** (undocumented -- nvdisasm can decode but labels them invalid):

| Mnemonic | Notes |
|----------|-------|
| `QMMA.INVALID2.F{16,32}.E4M3.E4M3` | 8 variants with INVALID2 tile |
| `QMMA.INVALID3.F{16,32}.E4M3.E4M3` | 8 variants with INVALID3 tile |
| `QMMA.16816.F16.E4M3.INVALID6` | Unknown Input B type (FP4?) |
| `QMMA.16832.F16.E4M3.INVALID6` | Unknown Input B type (FP4?) |

**Structured Sparsity (SP)** -- 2:4 sparsity support:

| Mnemonic | Tile | Notes |
|----------|------|-------|
| `QMMA.SP.16832.{F16,F32}.{E4M3,E5M2}.{E4M3,E5M2}` | 16×8×32 | 8 variants |
| `QMMA.SP.16864.{F16,F32}.{E4M3,E5M2}.{E4M3,E5M2}` | 16×8×64 | 8 variants (K doubles for sparse) |
| `QMMA.SP.INVALID0.{F16,F32}.{E4M3,E5M2}.{E4M3,E5M2}` | ??? | 8 variants, unknown tile |
| `QMMA.SP.INVALID3.{F16,F32}.{E4M3,E5M2}.{E4M3,E5M2}` | ??? | 8 variants, unknown tile |

**Scale Factor (SF)** -- Opcode 0x47a (MXFP4/MXFP8 block scaling):

| Mnemonic | Notes |
|----------|-------|
| `QMMA.SF.16832.F32.{E4M3,E5M2}.{E4M3,E5M2}.E8` | 4 base variants |
| `QMMA.SF.16832.F32.E4M3.{E2M3,INVALID6}.E8` | Additional Input B types |
| `QMMA.SF.SP.16864.F32.{E4M3,E5M2}.{E4M3,E5M2}.E8` | 4 variants: SF + Sparsity |

**MXFP4-related observations:**
- `QMMA.SF.16832.F32.E4M3.E4M3.E8` was observed in this dataset
- `E2M3` (2-bit exponent, 3-bit mantissa) appears as Input B -- this may be MXFP4's wire format
- `INVALID6` as Input B type -- potentially a newer FP4 variant not yet named in nvdisasm
- SF mode is **F32 output only** -- no F16 accumulator in scale-factor mode
- SP+SF combination exists at 16×8×64 tile -- structured sparsity + block scaling

---

## Modifier Taxonomy

The 1,894 unique mnemonics decompose into **282 unique modifier tokens** organized
into orthogonal categories:

### Data Types (802 occurrences across mnemonics)

| Token | Occurrences | Description |
|-------|-------------|-------------|
| `.U8` | 224 | Unsigned 8-bit |
| `.F32` | 109 | 32-bit float |
| `.F16x2` | 83 | Packed half-precision pair |
| `.F16` | 60 | 16-bit float (half) |
| `.E4M3` | 46 | FP8 (4-bit exp, 3-bit mantissa) |
| `.E5M2` | 41 | FP8 (5-bit exp, 2-bit mantissa) |
| `.S32` | 30 | Signed 32-bit |
| `.S8` | 30 | Signed 8-bit |
| `.U32` | 29 | Unsigned 32-bit |
| `.64` | 26 | 64-bit operand |
| `.BF16` | 23 | BFloat16 |
| `.E8` | 18 | FP8 scale format marker |
| `.128` | 17 | 128-bit operand |
| `.U16` | 16 | Unsigned 16-bit |
| `.U64` | 14 | Unsigned 64-bit |
| `.S16` | 13 | Signed 16-bit |
| `.S64` | 11 | Signed 64-bit |
| `.BF16x2` | 3 | Packed BFloat16 pair |
| `.BF16x4` | 3 | Packed BFloat16 quad |
| `.BF16x8` | 3 | Packed BFloat16 oct |
| `.E2M3` | 3 | FP5? (2-bit exp, 3-bit mantissa) |

### Cache Modes (733 occurrences)

| Token | hi64 bits [22:20] | Occurrences | Description |
|-------|-------------------|-------------|-------------|
| `.EF` | `000` | 667 | Evict First (default for many) |
| `.EL` | `010` | 22 | Evict Last |
| `.EU` | `100` | 22 | Evict Uniform |
| `.LU` | varies | 22 | Last Use |

### Rounding Modes (227 occurrences)

| Token | Occurrences | Description |
|-------|-------------|-------------|
| `.RN` | 108 | Round to Nearest Even |
| `.RZ` | 53 | Round toward Zero |
| `.RM` | 33 | Round toward Minus infinity |
| `.RP` | 33 | Round toward Plus infinity |

### Atomic Operations (470 occurrences)

| Token | hi64 bits [26:23] | Occurrences | Description |
|-------|-------------------|-------------|-------------|
| `.ADD` | `0000` | 307 | Atomic add |
| `.CAS` | `0001`? | 104 | Compare and swap |
| `.MIN` | varies | 17 | Atomic minimum |
| `.MAX` | varies | 14 | Atomic maximum |
| `.INC` | `0101` | 10 | Atomic increment |
| `.DEC` | varies | 10 | Atomic decrement |
| `.EXCH` | varies | 4 | Atomic exchange |
| `.CAST` | varies | 4 | Compare-and-swap with timeout |

### Memory Scope (409 occurrences)

| Token | hi64 bits [16:14] | Occurrences | Description |
|-------|-------------------|-------------|-------------|
| `.PRIVATE` | `001` | 127 | Thread-private scope |
| `.GPU` | varies | 91 | GPU-wide scope |
| `.SM` | varies | 88 | SM-local scope |
| `.CTA` | varies | 52 | CTA (block) scope |
| `.SYS` | varies | 51 | System-wide scope |

### Memory Consistency (341 occurrences)

| Token | Occurrences | Description |
|-------|-------------|-------------|
| `.CONSTANT` | 181 | Constant ordering |
| `.STRONG` | 107 | Strong ordering |
| `.MMIO` | 53 | Memory-mapped I/O |

### FP Special Modes (235 occurrences)

| Token | Occurrences | Description |
|-------|-------------|-------------|
| `.FTZ` | 117 | Flush subnormals to zero |
| `.SAT` | 65 | Saturate result to [0, 1] |
| `.FMZ` | 26 | Fused multiply-zero |
| `.SATFINITE` | 14 | Saturate to finite range |
| `.RELU` | 13 | ReLU activation (clamp negative to 0) |

### Comparison Predicates (149 occurrences)

| Ordered | Unordered | Count | Description |
|---------|-----------|-------|-------------|
| `.EQ` | `.EQU` | 13, 9 | Equal |
| `.NE` | `.NEU` | 11, 9 | Not equal |
| `.LT` | `.LTU` | 11, 9 | Less than |
| `.LE` | `.LEU` | 11, 9 | Less or equal |
| `.GT` | `.GTU` | 11, 9 | Greater than |
| `.GE` | `.GEU` | 11, 9 | Greater or equal |
| `.NUM` | `.NAN` | 9, 9 | Number / NaN test |
| `.F` | | 28 | False (never true) |

---

## Top 30 Instruction Families by Variant Count

| Family | Variants | Opcodes | Description |
|--------|----------|---------|-------------|
| ATOM | 131 | 3 | Global atomic operations |
| ATOMG | 129 | 3 | Generic-address atomics |
| REDG | 90 | 2 | Generic-address reductions |
| SUATOM | 83 | 2 | Surface atomic operations |
| **QMMA** | **78** | **2** | **Tensor core MMA (FP8/FP4)** |
| SULD | 68 | 2 | Surface load |
| SUST | 68 | 2 | Surface store |
| TEX | 57 | 1 | Texture fetch |
| SURED | 41 | 1 | Surface reduction |
| FMUL | 39 | 2 | FP32 multiply |
| FSETP | 35 | 2 | FP32 set predicate |
| FSET | 35 | 2 | FP32 set |
| ATOMS | 34 | 3 | Shared-memory atomics |
| F2FP | 33 | 3 | Float to packed float conversion |
| MEMBAR | 33 | 1 | Memory barrier |
| FFMA | 32 | 3 | FP32 fused multiply-add |
| HSET2 | 32 | 2 | FP16 packed set |
| HSETP2 | 32 | 2 | FP16 packed set predicate |
| LD | 31 | 1 | Generic load |
| LDG | 31 | 1 | Global load |
| ST | 31 | 1 | Generic store |
| STG | 31 | 1 | Global store |
| IMMA | 25 | 1 | Integer MMA |
| HFMA2 | 25 | 3 | FP16 packed fused multiply-add |
| ISETP | 24 | 2 | Integer set predicate |
| I2FP | 22 | 2 | Integer to packed float |
| F2IP | 19 | 3 | Float to packed integer |
| DSETP | 19 | 2 | FP64 set predicate |
| ISBERD | 19 | 1 | Indexed surface binding |
| LDSM | 18 | 1 | Load from shared memory (matrix) |

---

## Newly Discovered Instructions (Phase 5)

### Newly Decoded Opcodes

These 12-bit codes were not decoded in Phase 4 but are now decoded:

| Opcode | Mnemonic | Description |
|--------|----------|-------------|
| `0x305` | `F2I.U8`, `F2I.U8.BF16`, `F2I.U8.F16` | Float to integer (BF16/F16 source) |
| `0x845` | `I2FP.INVALID0.U32` | Integer to packed float (cbuf variant) |
| `0x95c` | `BPT.INT`, `BPT.TRAP` | **Breakpoint / trap instruction** |

### BPT.TRAP

`BPT.TRAP` is a hardware trap/breakpoint instruction. This is notable because:
- Not compiler-emitted (not in Phase 2)
- Only decoded with specific hi64 patterns (not found in Phase 4's 10 templates)
- Has two variants: `.INT` (interrupt) and `.TRAP` (trap)
- Used by debuggers and hardware exception handling

---

## Currently Unlabeled Opcodes

These opcodes **execute on hardware** (Phase 3) but **nvdisasm cannot decode them**
even with exhaustive hi64 pattern sweeps (Phase 5b):

| Opcode | bits[8:0] | Mode | Phase 3 | Notes |
|--------|-----------|------|---------|-------|
| `0x35a` | `0x15a` | 1 | VALID | Near NANOSLEEP (0x35d), BMOV (0x355) |
| `0x3d0` | `0x1d0` | 1 | TIMEOUT | Causes GPU hang. Near cache control ops |
| `0x95a` | `0x15a` | 4 | VALID | Same base as 0x35a, different source mode |
| `0x9d4` | `0x1d4` | 4 | VALID | Isolated in opcode space |

These entries are currently unlabeled by `nvdisasm` in this test set and were
observed executing in Phase 3 hardware probes.

---

## Appendix A: Source Mode Distribution

| Mode | Code Range | Opcode Count | Notes |
|------|-----------|--------------|-------|
| 1 (R-R) | 0x200-0x3FF | 106 | Primary encoding for most instructions |
| 4 (R-CB) | 0x800-0x9FF | 111 | Constant buffer source variant |
| 2 (R-I) | 0x400-0x5FF | 24 | Immediate source variant |
| 5 | 0xA00-0xBFF | 3 | BAR.SYNC, CCTL |
| 7 | 0xE00-0xFFF | 3 | SHFL, BMOV |
| 3 | 0x600-0x7FF | 1 | SEL.64 only |
| 0, 6 | — | 0 | Not used |

Mode 1 and Mode 4 are nearly always present together (same instruction, different
source encoding). Mode 2 is available for instructions that support immediate operands.

---

## Appendix B: nvdisasm Reverse Engineering Notes

### ROT13 Obfuscation

NVIDIA obfuscates SASS mnemonic strings in the `nvdisasm` binary using ROT13
character substitution. Decoding the `.rodata` section reveals the complete mnemonic
vocabulary, including instructions for architectures beyond SM121a.

### MDI Compressed Tables

The instruction decode tables are stored in a proprietary compressed format (MDI --
"Machine Description Information"?) in the `.data` section. Standard zlib decompression
fails, indicating a custom compression scheme. The tables map instruction bit patterns
to mnemonic strings and operand formats.

### Validity Bits

hi64 bits 27, 43, and 44 appear to be **format validation bits**. Setting any of
these to 1 causes nvdisasm to reject the instruction regardless of other field values.
This is consistent across ALL tested instruction families.

---

## Appendix C: Methodology Details

### Phase 5a Bit-Flip Protocol

For 11 known multi-mnemonic opcodes:
1. Established baseline: which of 10 templates produce which mnemonic
2. For each template that produces a mnemonic, flipped each of 52 bits in lo64[63:12]
3. Flipped each of 64 bits in hi64
4. Recorded every bit position where the mnemonic changed

Total probes: ~1,400 nvdisasm calls. Runtime: ~5 minutes.

### Phase 5b Smart Sweep

For 456 target opcodes (245 known + 4 truly-unknown + 207 adjacent):
- Generated 69 hi64 patterns covering: all 16 operation functions, all 8 data types,
  all 8 cache modes, 32 format/scope values, extended flag, alternate scheduling bases
- 3 lo64 bases + 5 lo64 modifier bit patterns per opcode
- 34,656 total .bin files processed with 64-way parallelism

Total probes: ~35,000. Runtime: ~8 minutes.

### Phase 5c QMMA Cross-Product

For 2 QMMA opcodes:
- Full cross-product of: 8 data types × 32 formats × 16 operations × 2 extended = 8,192 hi64 patterns
- Plus 64 type × cache cross patterns
- 3 lo64 bases per opcode
- 49,488 total .bin files processed with 64-way parallelism

Total probes: ~49,000. Runtime: ~20 minutes.
